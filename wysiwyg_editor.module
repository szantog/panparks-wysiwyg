<?php
// $Id$


/**
 * @file
 * Integrate Wysiwyg editors into Drupal.
 */

/**
 * Implementation of hook_menu().
 */
function wysiwyg_editor_menu() {
  $items = array();
  $items['admin/settings/wysiwyg/profile'] = array(
    'title' => 'Wysiwyg Editor',
    'page callback' => 'wysiwyg_editor_admin',
    'description' => 'Configure client-side editors profiles.',
    'access arguments' => array('administer site configuration'),
    'file' => 'wysiwyg_editor.admin.inc',
  );
  return $items;
}

/**
 * Implementation of hook_theme().
 */
function wysiwyg_editor_theme() {
  return array(
    'wysiwyg_editor_admin_button_table' => array('arguments' => array('form')),
  );
}

/**
 * Implementation of hook_help().
 */
function wysiwyg_editor_help($path, $arg) {
  switch ($path) {
    case 'admin/settings/wysiwyg/profile':
    case 'admin/help#wysiwyg_editor':
      $output = '<p>'. t('Profiles can be defined based on user roles. A Wysiwyg Editor profile can define which pages receive this Wysiwyg Editor capability, what buttons or themes are enabled for the editor, how the editor is displayed, and a few other editor functions. Lastly, only users with the %permission <a href="!url">user permission</a> are able to use Wysiwyg Editor.', array('%permission' => 'access wysiwyg editor', '!url' => url('admin/user/permissions'))) .'</p>';
      return $output;
  }
}

/**
 * Implementation of hook_perm().
 */
function wysiwyg_editor_perm() {
  $array = array('access wysiwyg editor');
  $wysiwyg_editor_mod_path = drupal_get_path('module', 'wysiwyg_editor');

  if (is_dir($wysiwyg_editor_mod_path .'/tinymce/jscripts/tiny_mce/plugins/imagemanager/')) {
    $array[] = 'access tinymce imagemanager';
  }
  if (is_dir($wysiwyg_editor_mod_path .'/tinymce/jscripts/tiny_mce/plugins/filemanager/')) {
    $array[] = 'access tinymce filemanager';
  }

  return $array;
}

/**
 * Implementation of hook_elements().
 *
 * @todo Remove #wysiwyg_style; the GUI for an editor should be solely handled
 *   via profiles, when profiles are attached to an input format. It makes no
 *   sense to display TinyMCE's simple GUI/theme for the user signature, when
 *   the input format allows users to use advanced HTML and hence, editor
 *   plugins.  Fix this here, in wysiwyg_editor_process_textarea(), and lastly
 *   in wysiwyg_editor_get_config().
 */
function wysiwyg_editor_elements() {
  $type = array();
  if (user_access('access wysiwyg editor')) {
    // Let Wysiwyg Editor potentially process each textarea.
    $type['textarea'] = array('#process' => array('wysiwyg_editor_process_textarea'), '#wysiwyg' => TRUE, '#wysiwyg_style' => 'advanced');
  }
  return $type;
}

/**
 * Implementation of hook_form_alter().
 */
function wysiwyg_editor_form_alter(&$form, &$form_state) {
  // Disable 'teaser' textarea.
  if (isset($form['body_field'])) {
    unset($form['body_field']['teaser_js']);
    $form['body_field']['teaser_include'] = array();
  }
}

/**
 * Alter #wysiwyg for certain core textareas.
 *
 * @param $element
 *   The textarea element to be processed.
 */
function wysiwyg_editor_filter_elements(&$element) {
  switch ($element['#name']) {
    // Disable Wysiwyg Editor for these textareas.
    case 'log': // Node revisions log message.
    case 'img_assist_pages': // Image Assist visibility settings.
    case 'caption': // User signature?
    case 'pages': // (Block) Visibility settings.
    case 'access_pages': // Wysiwyg Editor profile settings.
    case 'user_mail_welcome_body': // User settings.
    case 'user_mail_approval_body': // User settings.
    case 'user_mail_pass_body': // User settings.
    case 'synonyms': // Taxonomy terms.
    case 'description': // Taxonomy terms.
      $element['#wysiwyg'] = FALSE;
      break;

    // Force 'simple' theme for some smaller textareas.
    case 'signature': // User signature.
    case 'site_mission':
    case 'site_footer':
    case 'site_offline_message':
    case 'page_help': // Page content-type help message?
    case 'user_registration_help':
    case 'user_picture_guidelines':
      $element['#wysiwyg_style'] = 'simple';
      break;
  }
}

/**
 * Process a textarea for Wysiwyg Editor.
 */
function wysiwyg_editor_process_textarea($element) {
  wysiwyg_editor_filter_elements($element);

  if ($element['#wysiwyg']) {
    $profile = wysiwyg_editor_load_profile(wysiwyg_editor_current_profile());
    if ($profile && _wysiwyg_editor_page_match($profile)) {
      if (!wysiwyg_editor_load_editor($profile)) {
        // Bail out if editor could not be loaded.
        return $element;
      }
      // Check editor theme (and reset if needed).
      // Default to advanced theme if the requested one is not installed.
      $element['#wysiwyg_style'] = wysiwyg_editor_get_themes($profile, $element['#wysiwyg_style']);

      wysiwyg_editor_add_settings($profile, $element['#wysiwyg_style']);
      wysiwyg_editor_add_plugin_settings($profile);
      if (!isset($element['#attributes'])) {
        $element['#attributes'] = array();
      }
      if (!isset($element['#attributes']['class'])) {
        $element['#attributes']['class'] = 'wysiwyg wysiwyg-'. $element['#wysiwyg_style'];
      }
      else {
        $element['#attributes']['class'] .= ' wysiwyg wysiwyg-'. $element['#wysiwyg_style'];
      }
      // Set resizable to false to avoid drupal.js resizable function from
      // taking control of the textarea
      $element['#resizable'] = FALSE;
    }
  }

  return $element;
}

/**
 * Load an editor library and initialize basic Wysiwyg settings.
 *
 * @param $profile
 *   A wysiwyg editor profile.
 *
 * @return
 *   TRUE if the editor has been loaded, FALSE if not.
 *
 * @see wysiwyg_editor_process_textarea()
 */
function wysiwyg_editor_load_editor($profile) {
  static $settings_added;
  static $loaded = array();

  $name = $profile->settings['editor'];
  // Library files must only be loaded once.
  if (!isset($loaded[$name])) {
    // Load editor 
    $editor = wysiwyg_get_editor($name);
    if ($editor) {
      // Determine library files to load.
      if (isset($profile->settings['library']) && isset($editor['libraries'][$profile->settings['library']])) {
        $library = $profile->settings['library'];
        $files = $editor['libraries'][$profile->settings['library']]['files'];
      }
      else {
        // Fallback to the first by default (external libraries can change).
        $library = key($editor['libraries']);
        $files = array_shift($editor['libraries']);
        $files = $files['files'];
      }
      foreach ($files as $file) {
        drupal_add_js($editor['library path'] . '/' . $file);
      }
      // Load JavaScript integration files for this editor.
      if (isset($editor['js files'])) {
        $files = $editor['js files'];
      }
      foreach ($files as $file) {
        drupal_add_js($editor['js path'] . '/' . $file, 'module', 'footer');
      }

      $status = wysiwyg_editor_user_get_status($profile);
      drupal_add_js(array('wysiwygEditor' => array(
        'configs' => array($editor['name'] => array()),
        'showToggle' => $profile->settings['show_toggle'],
        'status' => $status,
        // If JS compression is enabled, at least TinyMCE is unable to determine
        // its own base path and exec mode since it can't find the script name.
        'editorBasePath' => base_path() . $editor['library path'],
        'execMode' => $library,
      )), 'setting');

      $loaded[$name] = TRUE;
    }
    else {
      $loaded[$name] = FALSE;
    }
  }

  // Add basic Wysiwyg settings.
  if (!isset($settings_added) && $loaded[$name]) {
    drupal_add_js(array('wysiwygEditor' => array(
      'configs' => array(),
      'disable' => t('Disable rich-text'),
      'enable' => t('Enable rich-text'),
    )), 'setting');

    // Add wysiwyg_editor.js to the footer to ensure it's executed after the
    // Drupal.settings array has been rendered and populated. Also, since editor
    // library initialization functions must be loaded first by the browser,
    // Drupal.wysiwygEditorInit() must be executed AFTER editors registered
    // their callbacks, and BEFORE Drupal.behaviors are applied, this must come
    // last.
    // @todo Separate into wysiwyg.init.js and wysiwyg.editor?.js, to ensure
    //   this logic/ordering, and do not force editor integration scripts to
    //   check and define Drupal.wysiwyg on its own.
    drupal_add_js(wysiwyg_get_path('wysiwyg_editor.js'), 'module', 'footer');

    // Add our stylesheet to stack editor buttons into one row.
    drupal_add_css(wysiwyg_get_path('wysiwyg_editor.css'));

    $settings_added = TRUE;
  }

  return $loaded[$name];
}

/**
 * Register a theme.
 */
function wysiwyg_editor_add_settings($profile, $theme) {
  static $themes = array();

  if (!isset($themes[$theme])) {
    $config = wysiwyg_editor_get_config($profile, $theme);
    // Convert the config values into the form expected by Wysiwyg Editor.
    // @todo Is this conversion TinyMCE specific?
    foreach ($config as $key => $value) {
      if (is_bool($value)) {
        continue;
      }
      if (is_array($value)) {
        $config[$key] = implode(',', $config[$key]);
      }
    }
    drupal_add_js(array('wysiwygEditor' => array('configs' => array($profile->settings['editor'] => array($theme => $config)))), 'setting');
    $themes[$theme] = TRUE;
  }
}

/**
 * Load external plugins.
 * 
 * @param $profile
 *   A wysiwyg editor profile.
 *
 * Note: tinyMCE.loadPlugin() need not be invoked more than once.
 */
function wysiwyg_editor_add_plugin_settings($profile) {
  static $plugins_added = array();
  
  if (!isset($plugins_added[$profile->settings['editor']])) {
    $plugins = array();
    $editor = wysiwyg_get_editor($profile->settings['editor']);
    $info = module_invoke_all('wysiwyg_plugin', $editor['name'], $editor['installed version']);

    if (isset($editor['plugin settings callback']) && function_exists($editor['plugin settings callback'])) {
      $plugins = $editor['plugin settings callback']($editor, $profile, $info);
    }

    drupal_add_js(array('wysiwygEditor' => array('plugins' => array($profile->settings['editor'] => $plugins))), 'setting');

    $plugins_added[$profile->settings['editor']] = TRUE;
  }
}

/**
 * Grab the themes available to Wysiwyg Editor.
 *
 * Wysiwyg Editor themes control the functionality and buttons that are available to a
 * user. Themes are only looked for within the default Wysiwyg Editor theme directory.
 *
 * @param $profile
 *   A wysiwyg editor profile; passed/altered by reference.
 * @param $selected_theme
 *   An optional theme name that ought to be used.
 *
 * @return
 *   An array of theme names, or a single, checked theme name if $selected_theme
 *   was given.
 */
function wysiwyg_editor_get_themes(&$profile, $selected_theme = NULL) {
  static $themes = array();

  if (!isset($themes[$profile->settings['editor']])) {
    $editor = wysiwyg_get_editor($profile->settings['editor']);
    if (isset($editor['themes callback']) && function_exists($editor['themes callback'])) {
      $themes[$editor['name']] = $editor['themes callback']($editor, $profile);
    }
    // Fallback to 'default' otherwise.
    else {
      $themes[$editor['name']] = array('default');
    }
  }

  // Check optional $selected_theme argument, if given.
  if (isset($selected_theme)) {
    // If the passed theme name does not exist, use the first available.
    if (!isset($themes[$profile->settings['editor']][$selected_theme])) {
      $selected_theme = $profile->settings['theme'] = $themes[$profile->settings['editor']][0];
    }
  }

  return isset($selected_theme) ? $selected_theme : $themes[$profile->settings['editor']];
}

/**
 * Return plugin metadata from the plugin registry.
 *
 * @param $editor_name
 *   The internal name of an editor to return plugins for.
 *
 * @return
 *   An array for each plugin.
 */
function wysiwyg_editor_get_plugins($editor_name) {
  $plugins = array();
  if (!empty($editor_name)) {
    $editor = wysiwyg_get_editor($editor_name);
    if (isset($editor['plugin callback']) && function_exists($editor['plugin callback'])) {
      $plugins = $editor['plugin callback']($editor);
    }
    // Load our own plugins.
    include_once drupal_get_path('module', 'wysiwyg_editor') .'/wysiwyg_editor.plugins.inc';
  
    $plugins = array_merge($plugins, module_invoke_all('wysiwyg_plugin', $editor['name'], $editor['installed version']));
  }
  return $plugins;
}

/**
 * Return an array of initial Wysiwyg Editor config options from the current role.
 */
function wysiwyg_editor_get_config($profile, $theme) {
  $editor = wysiwyg_get_editor($profile->settings['editor']);
  $settings = array();
  if (!empty($editor['settings callback']) && function_exists($editor['settings callback'])) {
    $settings = $editor['settings callback']($editor, $profile->settings, $theme);
  }
  return $settings;
}

/**
 * Return the name of the current user's default profile.
 */
function wysiwyg_editor_current_profile() {
  global $user;
  static $profile_name;

  if (!isset($profile_name)) {
    $profile_name = db_result(db_query_range('SELECT p.name FROM {wysiwyg_editor_profile} p INNER JOIN {wysiwyg_editor_role} r ON r.name = p.name WHERE r.rid IN (%s) ORDER BY plugin_count DESC', implode(',', array_keys($user->roles)), 0, 1));
  }
  return $profile_name;
}

/**
 * Load all profiles. Just load one profile if $name is passed in.
 */
function wysiwyg_editor_load_profile($name = '') {
  static $profiles;

  // If $name is passed from wysiwyg_editor_current_profile(), it may be FALSE,
  // which means the user is not allowed to use a wysiwyg editor.
  if ($name === FALSE) {
    return FALSE;
  }
  if (!isset($profiles)) {
    $profiles = array();
    $roles = user_roles();
    $result = db_query('SELECT * FROM {wysiwyg_editor_profile}');
    while ($profile = db_fetch_object($result)) {
      $profile->settings = unserialize($profile->settings);
      $result2 = db_query("SELECT rid FROM {wysiwyg_editor_role} WHERE name = '%s'", $profile->name);
      $profile_roles = array();
      while ($role = db_fetch_object($result2)) {
        $profile_roles[$role->rid] = $roles[$role->rid];
      }
      $profile->rids = $profile_roles;

      $profiles[$profile->name] = $profile;
    }
  }

  return ($name && isset($profiles[$name]) ? $profiles[$name] : ($name ? FALSE : $profiles));
}

/**
 * Determine if Wysiwyg Editor has permission to be used on the current page.
 *
 * @return
 *   TRUE if can render, FALSE if not allowed.
 */
function _wysiwyg_editor_page_match($profile) {
  $page_match = FALSE;
  if (!is_object($profile)) {
    return FALSE;
  }

  // Kill Wysiwyg Editor if we're editing a textarea with PHP in it!
  if (arg(0) == 'node' && is_numeric(arg(1)) && arg(2) == 'edit') {
    $node = node_load(arg(1));
    $filters = filter_list_format($node->format);
    foreach ($filters as $filter) {
      if ($filter->module == 'php') {
        return FALSE;
      }
    }
  }

  if ($profile->settings['access_pages']) {
    // If the PHP option wasn't selected
    if ($profile->settings['access'] < 2) {
      $path = drupal_get_path_alias($_GET['q']);
      $regexp = '/^('. preg_replace(array('/(\r\n?|\n)/', '/\\\\\*/', '/(^|\|)\\\\<front\\\\>($|\|)/'), array('|', '.*', '\1'. preg_quote(variable_get('site_frontpage', 'node'), '/') .'\2'), preg_quote($profile->settings['access_pages'], '/')) .')$/';
      $page_match = !($profile->settings['access'] xor preg_match($regexp, $path));
    }
    else {
      $page_match = drupal_eval($profile->settings['access_pages']);
    }
  }
  // No pages were specified to block so show on all
  else {
    $page_match = TRUE;
  }

  return $page_match;
}

/**
 * Implementation of hook_user().
 */
function wysiwyg_editor_user($type, &$edit, &$user, $category = NULL) {
  if ($type == 'form' && $category == 'account' && user_access('access wysiwyg editor')) {
    $profile = wysiwyg_editor_user_get_profile($user);
    if (isset($profile->settings['user_choose']) && $profile->settings['user_choose']) {
      $form['wysiwyg'] = array(
        '#type' => 'fieldset',
        '#title' => t('Wysiwyg Editor settings'),
        '#weight' => 10,
        '#collapsible' => TRUE,
        '#collapsed' => TRUE,
      );
      $form['wysiwyg']['wysiwyg_editor_status'] = array(
        '#type' => 'checkbox',
        '#title' => t('Enable editor by default'),
        '#default_value' => isset($user->wysiwyg_editor_status) ? $user->wysiwyg_editor_status : (isset($profile->settings['default']) ? $profile->settings['default'] : FALSE),
        '#return_value' => 1,
        '#description' => t('If enabled, rich-text editing is enabled by default in textarea fields.'),
      );
      return array('wysiwyg_editor' => $form);
    }
  }
  if ($type == 'validate') {
    return array('wysiwyg_editor_status' => $edit['wysiwyg_editor_status']);
  }
}

function wysiwyg_editor_user_get_profile($account) {
  $profile_name = db_result(db_query('SELECT s.name FROM {wysiwyg_editor_profile} s INNER JOIN {wysiwyg_editor_role} r ON r.name = s.name WHERE r.rid IN (%s)', implode(',', array_keys($account->roles))));
  if ($profile_name) {
    return wysiwyg_editor_load_profile($profile_name);
  }
  else {
    return FALSE;
  }
}

function wysiwyg_editor_user_get_status($profile) {
  global $user;
  $settings = $profile->settings;

  if ($settings['user_choose'] && isset($user->wysiwyg_editor_status)) {
    $status = $user->wysiwyg_editor_status;
  }
  else {
    $status = isset($settings['default']) ? $settings['default'] : FALSE;
  }

  return $status;
}

/**
 * @defgroup wysiwyg_editor_api Wysiwyg Editor API
 * @{
 * Description
 *
 * @todo Forked from Panels; abstract into a separate API module that allows
 *   contrib modules to define supported include/plugin types.
 */

/**
 * Return library information for a given editor.
 *
 * @param $name
 *   The internal name of an editor.
 *
 * @return
 *   The library information for the editor, or FALSE if $name is unknown or not
 *   installed properly.
 */
function wysiwyg_get_editor($name) {
  $editors = wysiwyg_get_all_editors();
  return isset($editors[$name]) && $editors[$name]['installed'] ? $editors[$name] : FALSE;
}

/**
 * Compile a list holding all supported editors including installed editor version information.
 */
function wysiwyg_get_all_editors() {
  static $editors;

  if (isset($editors)) {
    return $editors;
  }

  $editors = wysiwyg_load_includes('editors', 'editor');
  foreach ($editors as $editor => $properties) {
    // Fill in required properties.
    $editors[$editor] += array(
      'title' => '',
      'vendor url' => '',
      'download url' => '',
      'editor path' => wysiwyg_get_path($properties['name']),
      'library path' => wysiwyg_get_path($properties['name']),
      'libraries' => array(),
      'version callback' => NULL,
      'themes callback' => NULL,
      'settings callback' => NULL,
      'plugin callback' => NULL,
      'plugin settings callback' => NULL,
      'versions' => array(),
      'js path' => $properties['path'] .'/js',
      'css path' => $properties['path'] .'/css',
    );
    // Check whether library is present.
    if (!($editors[$editor]['installed'] = file_exists($properties['library path']))) {
      continue;
    }
    // Detect library version.
    if (function_exists($editors[$editor]['version callback'])) {
      $editors[$editor]['installed version'] = $editors[$editor]['version callback']($properties);
    }
    if (empty($editors[$editor]['installed version'])) {
      $editors[$editor]['error'] = t('The version of %editor could not be detected.', array('%editor' => $properties['title']));
      $editors[$editor]['installed'] = FALSE;
      continue;
    }
    // Determine to which supported version the installed version maps.
    ksort($editors[$editor]['versions']);
    $version = 0;
    foreach ($editors[$editor]['versions'] as $supported_version => $version_properties) {
      if (version_compare($editors[$editor]['installed version'], $supported_version, '>=')) {
        $version = $supported_version;
      }
    }
    if (!$version) {
      $editors[$editor]['error'] = t('The installed version of %editor is not supported.', array('%editor' => $properties['title']));
      $editors[$editor]['installed'] = FALSE;
      continue;
    }
    // Apply library version specific definitions and overrides.
    $editors[$editor] = array_merge($editors[$editor], $editors[$editor]['versions'][$version]);
    unset($editors[$editor]['versions']);
    $editors[$editor]['title'] = $editors[$editor]['title'] . ' ' . $editors[$editor]['installed version'];
  }
  return $editors;
}

/**
 * Load include files for wysiwyg implemented by all modules.
 *
 * @param $type
 *   The type of includes to search for, can be 'editors'.
 * @param $hook
 *   The hook name to invoke.
 * @param $file
 *   An optional include file name without .inc extension to limit the search to.
 *
 * @see wysiwyg_get_directories(), _wysiwyg_process_include()
 */
function wysiwyg_load_includes($type = 'editors', $hook = 'editor', $file = NULL) {
  // Determine implementations.
  $directories = wysiwyg_get_directories($type);
  $directories['wysiwyg_'] = wysiwyg_get_path($type);
  $file_list = array();
  foreach ($directories as $module => $path) {
    $file_list[$module] = drupal_system_listing("$file" . '.inc$', $path, 'name', 0);
  }

  // Load implementations.
  $info = array();
  foreach (array_filter($file_list) as $module => $files) {
    foreach ($files as $file) {
      include_once './' . $file->filename;
      $result = _wysiwyg_process_include('wysiwyg', $module . $file->name, dirname($file->filename), $hook);
      if (is_array($result)) {
        $info = array_merge($info, $result);
      }
    }
  }
  return $info;
}

/**
 * Helper function to build module/file paths.
 *
 * @param $file
 *   A file or directory in a module to return.
 * @param $base_path
 *   Whether to prefix the resulting path with base_path().
 * @param $module
 *   The module name to use as prefix.
 *
 * @return
 *   The path to the specified file in a module.
 */
function wysiwyg_get_path($file = '', $base_path = FALSE, $module = 'wysiwyg_editor') {
  $base_path = ($base_path ? base_path() : '');
  return $base_path . drupal_get_path('module', $module) . '/' . $file;
}

/**
 * Return a list of directories by modules implementing wysiwyg_include_directory().
 *
 * @param $plugintype
 *   The type of a plugin; can be 'editors'.
 *
 * @return
 *   An array containing module names suffixed with '_' and their defined
 *   directory.
 *
 * @see wysiwyg_load_includes(), _wysiwyg_process_include()
 */
function wysiwyg_get_directories($plugintype) {
  $directories = array();
  foreach (module_implements('wysiwyg_include_directory') as $module) {
    $result = module_invoke($module, 'wysiwyg_include_directory', $plugintype);
    if (isset($result) && is_string($result)) {
      $directories[$module .'_'] = drupal_get_path('module', $module) .'/'. $result;
    }
  }
  return $directories;
}

/**
 * Process a single hook implementation of a wysiwyg editor.
 *
 * @param $module
 *   The module that owns the hook.
 * @param $identifier
 *   Either the module or 'wysiwyg_' . $file->name
 * @param $hook
 *   The name of the hook being invoked.
 */
function _wysiwyg_process_include($module, $identifier, $path, $hook) {
  $function = $identifier . '_' . $hook;
  if (!function_exists($function)) {
    return NULL;
  }
  $result = $function();
  if (!isset($result) || !is_array($result)) {
    return NULL;
  }

  // Fill in defaults.
  foreach ($result as $editor => $properties) {
    $result[$editor]['module'] = $module;
    $result[$editor]['name'] = $editor;
    $result[$editor]['path'] = $path;
  }
  return $result;
}

/**
 * @} End of "defgroup wysiwyg_editor_api".
 */

